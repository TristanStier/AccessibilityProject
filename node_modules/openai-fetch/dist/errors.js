/**
 * Copied from OpenAI's official Node client for better compatibility,
 * without importing a huge amount of dependencies and unnecessary code.
 * @see: https://github.com/openai/openai-node/blob/master/src/error.ts
 */
export function castToError(err) {
    if (err instanceof Error)
        return err;
    return new Error(err);
}
export class OpenAIError extends Error {
}
export class APIError extends OpenAIError {
    status;
    headers;
    error;
    code;
    param;
    type;
    constructor(status, error, message, headers) {
        super(`${APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        const data = error;
        this.error = data;
        this.code = data?.['code'];
        this.param = data?.['param'];
        this.type = data?.['type'];
    }
    static makeMessage(status, error, message) {
        const msg = error?.message
            ? typeof error.message === 'string'
                ? error.message
                : JSON.stringify(error.message)
            : error
                ? JSON.stringify(error)
                : message;
        if (status && msg) {
            return `${status} ${msg}`;
        }
        if (status) {
            return `${status} status code (no body)`;
        }
        if (msg) {
            return msg;
        }
        return '(no status code or body)';
    }
    static generate(status, errorResponse, message, headers) {
        if (!status) {
            return new APIConnectionError({ cause: castToError(errorResponse) });
        }
        const error = errorResponse?.['error'];
        if (status === 400) {
            return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
            return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
            return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
            return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
            return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
            return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
            return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
            return new InternalServerError(status, error, message, headers);
        }
        return new APIError(status, error, message, headers);
    }
}
export class APIUserAbortError extends APIError {
    status = undefined;
    constructor({ message } = {}) {
        super(undefined, undefined, message || 'Request was aborted.', undefined);
    }
}
export class APIConnectionError extends APIError {
    status = undefined;
    constructor({ message, cause, }) {
        super(undefined, undefined, message || 'Connection error.', undefined);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause)
            this.cause = cause;
    }
}
export class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
        super({ message: message ?? 'Request timed out.' });
    }
}
export class BadRequestError extends APIError {
    status = 400;
}
export class AuthenticationError extends APIError {
    status = 401;
}
export class PermissionDeniedError extends APIError {
    status = 403;
}
export class NotFoundError extends APIError {
    status = 404;
}
export class ConflictError extends APIError {
    status = 409;
}
export class UnprocessableEntityError extends APIError {
    status = 422;
}
export class RateLimitError extends APIError {
    status = 429;
}
export class InternalServerError extends APIError {
}
//# sourceMappingURL=errors.js.map