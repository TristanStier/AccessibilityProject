{"version":3,"file":"streaming.js","sourceRoot":"","sources":["../src/streaming.ts"],"names":[],"mappings":"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","sourcesContent":["/** A function that converts from raw Completion response from OpenAI\n * into a nicer object which includes the first choice in response from OpenAI.\n */\ntype ResponseFactory<Raw, Nice> = (response: Raw) => Nice;\n\n/**\n * A parser for the streaming responses from the OpenAI API.\n *\n * Conveniently shaped like an argument for WritableStream constructor.\n */\nclass OpenAIStreamParser<Raw, Nice> {\n  private responseFactory: ResponseFactory<Raw, Nice>;\n  onchunk?: (chunk: Nice) => void;\n  onend?: () => void;\n  buffer: string;\n\n  constructor(responseFactory: ResponseFactory<Raw, Nice>) {\n    this.responseFactory = responseFactory;\n    this.buffer = '';\n  }\n\n  /**\n   * Takes the ReadableStream chunks, produced by `fetch` and turns them into\n   * `CompletionResponse` objects.\n   * @param chunk The chunk of data from the stream.\n   */\n  write(chunk: Uint8Array): void {\n    const decoder = new TextDecoder();\n    const s = decoder.decode(chunk);\n    let parts = s.split('\\n');\n\n    // Buffer incomplete line.\n    if (parts.length === 1) {\n      this.buffer += parts[0];\n      return;\n    }\n\n    // Prepend the buffer to the first part.\n    if (this.buffer.length > 0) {\n      parts[0] = this.buffer + parts[0];\n      this.buffer = '';\n    }\n\n    // If the last part isn't an empty string, then we need to buffer it.\n    const last = parts[parts.length - 1];\n    if (last && last.length > 0) {\n      this.buffer = parts.pop()!;\n    }\n\n    parts\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0)\n      .forEach((line) => {\n        const pos = line.indexOf(':');\n        const name = line.substring(0, pos);\n        if (name !== 'data') return;\n        const content = line.substring(pos + 1).trim();\n        if (content.length == 0) return;\n        if (content === '[DONE]') {\n          this.onend?.();\n          return;\n        }\n        try {\n          const parsed = JSON.parse(content);\n          this.onchunk?.(this.responseFactory(parsed));\n        } catch (e) {\n          console.error('Failed parsing streamed JSON chunk', e);\n        }\n      });\n  }\n}\n\n/**\n * A transform stream that takes the streaming responses from the OpenAI API\n * and turns them into useful response objects.\n */\nexport class StreamCompletionChunker<Raw, Nice>\n  implements TransformStream<Uint8Array, Nice>\n{\n  writable: WritableStream<Uint8Array>;\n  readable: ReadableStream<Nice>;\n\n  constructor(responseFactory: ResponseFactory<Raw, Nice>) {\n    const parser = new OpenAIStreamParser(responseFactory);\n    this.writable = new WritableStream(parser);\n    this.readable = new ReadableStream({\n      start(controller) {\n        parser.onchunk = (chunk: Nice) => controller.enqueue(chunk);\n        parser.onend = () => controller.close();\n      },\n    });\n  }\n}\n"]}